# Stack


## TS

|Utility|<img src="https://img.shields.io/badge/TypeScript ^4.7.4-007ACC?style=flat-square&logo=TypeScript&logoColor=white"/>|
|:---|:---|

## Envioronment

|NodeJS|<img src="https://img.shields.io/badge/Node.js v17.7.2-339933?style=flat-square&logo=node.js&logoColor=white"/>  |
|:---|:---|
|NPM|<img src="https://img.shields.io/badge/NPM v8.5.2 -CB3837?style=flat-square&logo=npm&logoColor=white"/> |

## CLI (예정)
|Netlify|<img src="https://img.shields.io/badge/Netlify v17.7.2-00C7B7?style=flat-square&logo=Netlify&logoColor=white"/>  |
|:---|:---|


## Style 

|Style & UI Library|<img src="https://img.shields.io/badge/Mantine ^5.2.4-58a6ff?style=flat-square&logo=data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjU2cHgiIGhlaWdodD0iMjU4cHgiIHZpZXdCb3g9IjAgMCAyNTYgMjU4IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQiPgogICAgPHRpdGxlPk1hbnRpbmU8L3RpdGxlPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI1NiwxMjguNjYxNDYyIEMyNTYsNTcuNjA0MDI1NiAxOTguNjkyNzY0LDAgMTI4LjAwMTU3OSwwIEM1Ny4zMDcyMzYsMCAwLDU3LjYwNDAyNTYgMCwxMjguNjYxNDYyIEMwLDE5OS43MTczMiA1Ny4zMDcyMzYsMjU3LjMyMjkyNCAxMjgsMjU3LjMyMjkyNCBDMTk4LjY5Mjc2NCwyNTcuMzIyOTI0IDI1NiwxOTkuNzE3MzIgMjU2LDEyOC42NjE0NjIgWiIgZmlsbD0iIzMzOUFGMCI+PC9wYXRoPgogICAgICAgIDxwYXRoIGQ9Ik0xMTAuNTc2MjM5LDY0LjExMTI5NjEgQzExMy4xMzE1MTUsNjMuNzMyMjM2NyAxMTUuNzMyNDg5LDY0LjM4NzMwOTcgMTE3LjgwMzM4Miw2NS45MzE1MDA2IEMxMjIuMDQ1MTI3LDY5LjA5NDEyMjYgMTI1Ljk1Nzk4NSw3Mi42NzM2NTEyIDEyOS40ODM2MzksNzYuNjE1ODM4NyBMMTMwLjM1Njk1Miw3Ny42MDg5MDk2IEwxNTcuOTY2MjgxLDc3LjYwODkwOTYgQzE2My4zNTExMTgsNzcuNjA4OTA5NiAxNjcuNzExNCw4MS45ODMzOTkzIDE2Ny43MTE0LDg3LjM4NTYwMjEgQzE2Ny43MTE0LDkyLjY2OTI5OTQgMTYzLjUzNTIwOSw5Ni45Njg5NDMxIDE1OC4zMjMyMTIsOTcuMTU3NDI5MSBMMTU3Ljk2NjI4MSw5Ny4xNjM4NzMyIEwxNDIuNzE2MzQ1LDk3LjE2Mzg3MzIgQzE0Ni45NzY4NjMsMTA2Ljk3Mjk0OSAxNDkuMTY0MzMyLDExNy41NTY2NDMgMTQ5LjE0MTUyNSwxMjguMjUxMDA4IEMxNDkuMTYyNjE3LDEzOC41NjI1MTQgMTQ3LjEyODg2NywxNDguNzcwOTYxIDE0My4xNjMzMjYsMTU4LjI4MTE5NyBMMTQyLjcxNDc2NywxNTkuMzM0OTg2IEwxNTcuOTU2ODA5LDE1OS4zMzQ5ODYgQzE2My4zNDMyMjUsMTU5LjMzNDk4NiAxNjcuNzAzNTA2LDE2My43MTEwNTQgMTY3LjcwMzUwNiwxNjkuMTEzMjU3IEMxNjcuNzAzNTA2LDE3NC4zOTU0MTEgMTYzLjUyNTgwNiwxNzguNjk2NTMgMTU4LjMxMzc0MywxNzguODg1MDgyIEwxNTcuOTU2ODA5LDE3OC44OTE1MjggTDEzMC4zNDExNjUsMTc4Ljg5MTUyOCBDMTI2LjU5MzkxNCwxODMuMjIyOTkxIDEyMi4zODczNjIsMTg3LjEzNDcwOCAxMTcuNzk1NDg4LDE5MC41NTc4ODcgQzExNS43MjE5MDYsMTkyLjEwNDE1OSAxMTMuMTE3MzAzLDE5Mi43NTk2NzcgMTEwLjU1ODgwMSwxOTIuMzc5MTkgQzEwOC4wMDAyOTksMTkxLjk5ODcwNCAxMDUuNjk5MTYsMTkwLjYxMzYzMyAxMDQuMTY1MjY3LDE4OC41MzA4NzcgQzEwMy40MDQzNDksMTg3LjUwMDAwNiAxMDIuODUzMzk0LDE4Ni4zMjcwNTYgMTAyLjU0MjM5NiwxODUuMDc5OTA4IEMxMDEuOTEyOTE1LDE4Mi41NjI2NjEgMTAyLjMwNjg4NSwxNzkuODk4NTMzIDEwMy42Mzc5OTIsMTc3LjY3MTIxOCBDMTA0LjI5Mzk1LDE3Ni41NzIyMjQgMTA1LjE2MDk5NCwxNzUuNjEzOTY4IDEwNi4xODkxMiwxNzQuODUxNzE2IEMxMjEuMDk4MDYyLDE2My43NDQyMDYgMTI5LjY1NzYwMiwxNDYuNzYwODkzIDEyOS42NTc2MDIsMTI4LjI0OTQzIEMxMjkuNjU3NjAyLDEwOS43Mzc5NjYgMTIxLjA5ODA2Miw5Mi43NTQ2NTI4IDEwNi4xODkxMiw4MS42NDcxNDMgQzEwNS4xNTk4LDgwLjg4NTI2ODEgMTA0LjI5MTY1Miw3OS45MjY5NzkxIDEwMy42MzQ4MzQsNzguODI3NjQxNSBDMTAxLjY4MzI5NSw3NS41NDkyNjgxIDEwMS44MDc4OTgsNzEuNDUxMzA5NiAxMDMuOTIyMTY1LDY4LjMwNTYwMzQgTDEwNC4xNjUyNjcsNjcuOTYwMDg5MyBDMTA1LjcxNDU5Nyw2NS44Nzk5NDU4IDEwOC4wMTY4NzEsNjQuNDk1NzQyOSAxMTAuNTc2MjM5LDY0LjExMTI5NjEgWiBNMTA4LjgyMDc1OSwxMTEuNTIxODYxIEMxMTAuNTk4OTU5LDExMi4yNzk5MzYgMTEyLjIwNjc5MSwxMTMuMzg3NDM0IDExMy41NDg4NzEsMTE0Ljc3ODY1MyBDMTE0Ljg5NjExMSwxMTYuMTc1NjggMTE1Ljk1MTcxMiwxMTcuODI2OTY5IDExNi42NTQxMTEsMTE5LjYzNjIxNiBDMTE3LjM1ODI5MiwxMjEuNDUwNTgyIDExNy42OTYzMSwxMjMuMzg2NDA3IDExNy42NDg2NzIsMTI1LjMzMjA1MSBDMTE3LjU2MTEzOSwxMjkuMTMzNTIgMTE2LjAwMTk2OSwxMzIuNzUyNzE5IDExMy4yOTk0NDEsMTM1LjQyNzYzNCBDMTEwLjYxNDkxNiwxMzguMDg0MjA1IDEwNi45OTE2ODQsMTM5LjU3NTkyNCAxMDMuMjE0OTA5LDEzOS41Nzk1MzIgQzk5LjQzNzAzOTEsMTM5LjU3Njc1NSA5NS44MTI1MjE1LDEzOC4wODQ5NzQgOTMuMTI3MjE4NSwxMzUuNDI3NjM0IEM5MC40MjQ2OTA2LDEzMi43NTI3MTkgODguODY1NTIwNCwxMjkuMTMzNTIgODguNzc3OTg3NCwxMjUuMzMyMDUxIEM4OC43MzE0Mzg1LDEyMy4zODYyMDMgODkuMDcwNTI4MiwxMjEuNDUwMzg3IDg5Ljc3NTcwNTgsMTE5LjYzNjIxNiBDOTAuNDc4MTA1MiwxMTcuODI2OTY5IDkxLjUzMzcwNjEsMTE2LjE3NTY4IDkyLjg4MDk0NjIsMTE0Ljc3ODY1MyBDOTQuMjIyNTM1NCwxMTMuMzg3NTc1IDk1LjgyOTgyMjQsMTEyLjI4MDA4MiA5Ny42MDc0Nzg5LDExMS41MjE4NjEgQzEwMS4xODk0MywxMDkuOTk1NTkgMTA1LjIzODgwOCwxMDkuOTk1NTkgMTA4LjgyMDc1OSwxMTEuNTIxODYxIFoiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgIDwvZz4KPC9zdmc+Cg==&logoColor=white"/> |
|:---|:---|






## Remix

|Remix|<img src="https://img.shields.io/badge/Remix ^1.7.0-7e7e7e?style=flat-square&logo=Remix&logoColor=white"/> |
|:---|:---|
|server state|<img src="https://img.shields.io/badge/Remix ^1.7.0-7e7e7e?style=flat-square&logo=Remix&logoColor=white"/> |
|Drag & Drop|<img src="https://img.shields.io/badge/react beautiful dnd ^13.1.1-0baf7c?style=flat-square&logo=react&logoColor=white"/> |
|Forms|<img src="https://img.shields.io/badge/Remix ^1.7.0-7e7e7e?style=flat-square&logo=Remix&logoColor=white"/> |



## DB
가벼움과 단숨함을 이유로 아래와 같은 세팅을 선택했습니다. 
<br/>
풀스택으로 전반적인 웹 흐름을 이해해보고자 하는 욕구도 있었지만, 
<br/>
기존 목표는 풀스택이 아닌 SSR이었기 때문에, 
<br/>
레퍼런스가 있고 비교적 심플하고 간단한 SQLite + Prisma 조합을 선택하였습니다.

|DMBS|<img src="https://img.shields.io/badge/SQLite ^3.39.3-003B57?style=flat-square&logo=SQLite&logoColor=white"/>   |
|:---|:---|
|ORM|<img src="https://img.shields.io/badge/Prisma ^4.3.1-2D3748?style=flat-square&logo=Prisma&logoColor=white"/>   |

<br/>
<br/>

# Tree (Directory)

```bash
.
├── README.md
├── app
│   ├── components <-- 공통 컴포넌트를 관리합니다.
│   │   └── Layout.tsx
│   ├── entry.client.tsx  <-- 브라우저 번들의 진입점입니다. entry.server.tsx에서 생성된 마크업을 ReHydrate하는데 사용됩니다.
│   ├── entry.server.tsx  <-- SSR이 이루어지는 진입점입니다. 기본적인 마크업, HTTP Response를 생성하는데 사용됩니다. 
│   ├── models  <-- db model을 관리합니다.
│   │   ├── todo.server.ts
│   │   └── user.server.ts
│   ├── pages   <-- 각 라우터 별 필요한 구성요소들을 관리합니다. 해당 요소들은 해당 라우터에서만 사용됩니다. 
│   │   ├── auth
│   │   │   ├── AuthModal.tsx
│   │   │   ├── controller  <-- 비즈니스 로직을 관리합니다. 순수 함수, 커스텀 훅, contextAPI를 각각 utils, hooks, context 폴더에 넣어 관리합니다.
│   │   │   │   ├── context
│   │   │   │   │   └── AuthUXProvider.tsx
│   │   │   │   └── utils
│   │   │   │       └── authUtils.ts
│   │   │   ├── errors  <-- 라우터의 에러를 핸들링 할 컴포넌트를 관리합니다
│   │   │   │   └── AuthErrorContainer.tsx
│   │   │   └── styles  <-- 라우터의 스타일을 관리합니다.
│   │   │       └── authStyles.tsx
│   │   ├── errors  <-- 글로벌 에러 모듈을 관리합니다.
│   │   │   ├── ErrorHandler.tsx
│   │   │   └── styles
│   │   │       └── errorHandlerStyles.tsx
│   │   ├── home
│   │   │   ├── HomContent.tsx
│   │   │   ├── components
│   │   │   ├── errors
│   │   │   │   └── DefaultErrorContainer.tsx
│   │   │   └── styles
│   │   │       └── homeContentStyles.tsx
│   │   ├── todo
│   │   │   ├── TodoDetail.tsx
│   │   │   ├── components
│   │   │   │   ├── DefaultDescriptionContainer.tsx
│   │   │   │   └── UpdateDescriptionContainer.tsx
│   │   │   ├── controller
│   │   │   │   ├── context
│   │   │   │   │   └── TodoModalProvider.tsx
│   │   │   │   ├── hook
│   │   │   │   │   └── useDropList.tsx
│   │   │   │   └── utils
│   │   │   │       └── handleArray.ts
│   │   │   ├── errors
│   │   │   │   └── TodoErrorContainer.tsx
│   │   │   └── styles
│   │   │       └── todoDetailStyles.tsx
│   │   └── todos
│   │       ├── TodoCard.tsx
│   │       ├── TodoList.tsx
│   │       ├── TodoProgress.tsx
│   │       ├── errors
│   │       │   └── ListErrorContainer.tsx
│   │       └── styles
│   │           ├── todoCardStyles.tsx
│   │           └── todoProgressStyles.tsx
│   ├── root.tsx  
│   ├── routes  <— 라우터의 집합소입니다. 해당 라우터의 action / loader / Error등 서버상태를 관리하며 뼈대의 역할을 합니다.
│   │   ├── auth
│   │   │   ├── login.tsx
│   │   │   └── register.tsx
│   │   ├── auth.tsx
│   │   ├── delete.tsx
│   │   ├── index.tsx
│   │   ├── logout.tsx
│   │   ├── todos
│   │   │   └── $id.tsx
│   │   └── todos.tsx
│   ├── styles  <— 글로벌 스타일을 관리합니다
│   │   ├── commonStyles.ts
│   │   └── reset.css
│   ├── types  <— 글로벌 타입을 관리합니다
│   │   └── commontypes.ts
│   └── utils  <— 서버측을 관리합니다. session, db, action handler등을 관리합니다.
│       ├── actionHandler.server.ts
│       ├── db.server.ts
│       └── session.server.ts
├── emotion.d.ts
├── jsconfig.json
├── netlify.toml
├── package-lock.json
├── package.json
├── prisma
│   ├── dev.db
│   ├── migrations
│   │   ├── 20220922174416_
│   │   │   └── migration.sql
│   │   ├── 20220926185647_
│   │   │   └── migration.sql
│   │   └── migration_lock.toml
│   ├── schema.prisma
│   └── seed.ts  <— 개발용 초기 목 데이터를 관리합니다.
├── remix.config.js
├── remix.env.d.ts
├── server.js
└── tsconfig.json
```

<br/>
<br/>

# Action / Loader

우리는 서버를 빠르게 만들 수는 있지만 유저의 네트워크를 제어할 순 없습니다.
<br/>
리믹스가 선택한 방법은 네트워크를 통해 보내는 양을 줄이는 것 입니다.
<br/>
<br/>
모든 request response는 서버에서 이루어지며, 
<br/>
client에는 필요한 데이터만 보낼 수 있습니다. 
<br/>
클라이언트에서는 useActionData , useLoaderData API로 
<br/>
결과값을 넘겨받기만 합니다.
<br/>
심플합니다.

## routes/todos/$id.tsx

loader

```js
export const loader = async ({ params }: LoaderArgs) => {
  const { id } = params;

  if (!id) {
    throw new Response('User Not Found', {
      status: 404,
      statusText: `User Not Found`,
    });
  }
  const todo = await getSingleTodo(id);

  if (!todo) {
    throw new Response('Todo Not Found', {
      status: 404,
      statusText: `Todo Not Found`,
    });
  }

  return json<TodoLoaderData>({ ...todo });
};

```

action

```js
export const action: ActionFunction = async ({ request }: ActionArgs) => {
  const formData = await request.formData();
  const { _action, _id, ...values } = Object.fromEntries(formData);

  invariant(typeof _action === 'string', `${_action} must be a string`);
  invariant(typeof _id === 'string', `${_id} must be a string`);

  if (_action === 'update') {
    await updateSingleTodo({ _id, ...values });
    return redirect(`/todos/${_id}`);
  }
  if (_action === 'delete') {
    await deleteTodo({ _id });
    return redirect('/todos');
  }

  if (_action === 'categoryUpdate') {
    await updateSingleTodo({ _id, ...values });
    return redirect(`/todos/${_id}`);
  }
  return;
};

```

route
```js
export default function $idRoute() {
  const { ...data } = useLoaderData() as TodoLoaderData;

  return <TodoDetail todo={data} />;
}
```
<br/>
<br/>

# Table Models

prisma를 통해 건내줄 데이터를 
<br/>
쉽고 간단하게 가공합니다.
<br/>
Remix에서 server.ts와 같이 파일 명에 server가 붙는다면 
<br/>
해당 파일은 서버에서만 실행됩니다. 
<br/>
반대로 client.ts도 마찬가지입니다.


## models/user.server.ts
```js
import { db } from '~/utils/db.server';

interface userParams {
  username: string;
  passwordHash: string;
}

export async function createUser({ username, passwordHash }: userParams) {
  return db.user.create({
    data: { username, passwordHash },
  });
}

export async function checkUser(username: string) {
  return db.user.findFirst({
    where: { username },
  });
}

export async function findUser(username: string) {
  return db.user.findUnique({
    where: { username },
  });
}

export async function findUserWithId(userId: string) {
  return db.user.findUnique({
    where: { id: userId },
    select: { id: true, username: true },
  });
}

```

<br/>
<br/>

# Server state handler

useTransition, useFetcher, useCatch, useActionData, useLoaderData 등 
<br/>
remix의 서버 상태관리 API들은 정말 쉽고 간단하게 
<br/>
server state를 관리해줍니다.

## routes/auth/login.tsx

```js
export default function LoginRoute() {
  const actionData = useActionData() as AuthBadRequestResponse;
  const { classes } = authStyles();
  const { wrapper, label, input, errorInput, errorMessage, button } = classes;
  const { setActionData } = useAuthUX();

  useEffect(() => {
    if (!actionData) return;
    setActionData(actionData);
  }, [setActionData, actionData]);

  return (
    <Form method="post">
      <Box className={wrapper}>
        <Space h={20} />
        <Input.Label htmlFor="username-input" mt={4} className={label}>
          <Input
            id="username-input"
            name="username"
            type="text"
            defaultValue={actionData?.fields?.username}
            aria-label="username"
            aria-invalid={Boolean(actionData?.fieldErrors?.username) || Boolean(actionData?.formError)}
            aria-errormessage={(actionData?.fieldErrors?.username && 'username-error') || (actionData?.formError && 'User does not exist.')}
            placeholder="username"
            className={input}
            //@ts-ignore
            styles={{ input: (actionData?.fieldErrors?.username || actionData?.formError) && errorInput }}
          />
          <Input.Error className={errorMessage}>{actionData?.fieldErrors?.username || actionData?.formError} </Input.Error>
        </Input.Label>
        <Input.Label htmlFor="password-input" mt={4} className={label}>
          <Input
            id="password-input"
            name="password"
            type="password"
            defaultValue={actionData?.fields?.password}
            aria-label="password"
            aria-invalid={Boolean(actionData?.fieldErrors?.password) || Boolean(actionData?.formError)}
            aria-errormessage={(actionData?.fieldErrors?.password && 'password-error') || (actionData?.formError && 'User does not exist.')}
            placeholder="password"
            className={input}
            //@ts-ignore
            styles={{ input: (actionData?.fieldErrors?.password || actionData?.formError) && errorInput }}
          />
          <Input.Error className={errorMessage}>{actionData?.fieldErrors?.password || actionData?.formError} </Input.Error>
        </Input.Label>
        <Button type="submit" variant="gradient" className={button} mt={8}>
          Log in
        </Button>
        <Space h={60} />
      </Box>
    </Form>
  );
}
```

<br/>
<br/>

# Error handler

React의 ErrorBoundary와 같이 
정말 쉽고 간단하게 
Remix도 에러를 가둘 수 있습니다. 
<br/>
더욱더 나아가 
<br/>
예상치 못한 에러 (500 status, server error) 
<br/>
예상 가능한 에러 (400 status, client error)
<br/>
모두 나누어 독립적으로 관리가 가능합니다. 
<br/>
이는 remix의 중첩 라우팅과 어우러져 강력한 nesting 기능을 갖춥니다.

<br/>

## routes/todos/$id.tsx

```js
export default function $idRoute() {
  const { ...data } = useLoaderData() as TodoLoaderData;

  return <TodoDetail todo={data} />;
}

export function CatchBoundary() {
  const caught = useCatch();
  const params = useParams();

  const error = { ...caught, ...{ name: caught.data.name || '', message: `Todo id : ${params.id} does not exist.` } };

  if (caught.status === 404) {
    return <TodoErrorContainer error={error} />;
  }
  throw new Error(`Unhandled error: ${caught.status}`);
}

export function ErrorBoundary({ error }: { error: CaughtError }) {
  return <TodoErrorContainer error={error} />;
}

```

<br/>
<br/>


# Session / Cookie

Remix는 Full Stack Framework이기 때문에 
<br/>
혼자서도 간단한 로그인 인증, 인가도 구현할 수 있습니다.

## utils/session.server.ts

```js
import { createCookieSessionStorage, redirect } from '@remix-run/node';
import { findUser, findUserWithId, createUser } from '~/models/user.server';
import bcrypt from 'bcryptjs';
import invariant from 'tiny-invariant';
import { User } from '@prisma/client';

interface authParameter {
  username: string;
  password: string;
}

invariant(process.env.SESSION_SECRET, 'SESSION_SECRET must be set');

export const sessionStorage = createCookieSessionStorage({
  cookie: {
    name: 'Remix_TodoList_session',
    /**
     * Safari localhost에서는 `secure: true`가 동작하는 않는 이슈가 있음
     *  https://web.dev/when-to-use-local-https/
     **/
    secure: process.env.NODE_ENV === 'production',
    secrets: [process.env.SESSION_SECRET],
    sameSite: 'lax',
    path: '/',
    maxAge: 60 * 60 * 24 * 30,
    httpOnly: true,
  },
});

const USER_SESSION_KEY = 'userId';

function getUserSession(request: Request) {
  const cookie = request.headers.get('Cookie');
  return sessionStorage.getSession(cookie);
}

export async function login({ username, password }: authParameter) {
  // find User
  const user = await findUser(username);

  if (!user) return;

  // password validation
  const isCorrectPassword = await bcrypt.compare(password, user.passwordHash);

  if (!isCorrectPassword) return;

  return { id: user.id, username };
}

export async function logout(request: Request) {
  const session = await getUserSession(request);

  return redirect('/', {
    headers: {
      'Set-Cookie': await sessionStorage.destroySession(session),
    },
  });
}

export async function register({ username, password }: authParameter) {
  const passwordHash = await bcrypt.hash(password, 10);
  const user = await createUser({ username, passwordHash });
  const { id } = user;
  return { id, username };
}

export async function getUserId(request: Request): Promise<User['id'] | undefined> {
  const session = await getUserSession(request);
  const userId = session.get(USER_SESSION_KEY);
  if (!userId || typeof userId !== 'string') return;
  return userId;
}

export async function getUser(request: Request) {
  const userId = await getUserId(request);

  if (typeof userId !== 'string') return;

  try {
    const user = await findUserWithId(userId);
    return user;
  } catch {
    throw logout(request);
  }
}

export async function requireUserId(request: Request, redirectTo = new URL(request.url).pathname) {
  const userId = await getUserId(request);
  if (!userId || typeof userId !== 'string') {
    const searchParams = new URLSearchParams([['redirectTo', redirectTo]]);
    throw redirect(`/auth/login?${searchParams}`);
  }
  return userId;
}

export async function createUserSession(userId: string, redirectTo: string) {
  const session = await sessionStorage.getSession();

  session.set(USER_SESSION_KEY, userId);
  return redirect(redirectTo, {
    headers: {
      'Set-Cookie': await sessionStorage.commitSession(session),
    },
  });
}

```
